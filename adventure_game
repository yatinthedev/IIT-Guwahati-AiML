# adventure_game.py
# A simple text-based adventure game where the player searches for a legendary treasure.
# Demonstrates Python fundamentals: functions, loops, conditionals, lists, and input handling.

import sys
import time
import random

def slow_print(text, delay=0.02):
    """Print text slowly for a better CLI experience."""
    for ch in text:
        sys.stdout.write(ch)
        sys.stdout.flush()
        time.sleep(delay)
    print()

def get_choice(prompt, choices):
    """
    Prompt the user to choose from choices (list of valid lower-case strings).
    Returns the chosen option (lowercased).
    """
    choice = ""
    choices_display = "/".join(choices)
    while True:
        choice = input(f"{prompt} ({choices_display}): ").strip().lower()
        if choice in choices:
            return choice
        else:
            print("Invalid choice. Please try again.")

def start_game():
    slow_print("Welcome, explorer! Your quest is to find the legendary treasure hidden in the ancient land.")
    name = input("What is your name, brave explorer? ").strip()
    if not name:
        name = "Explorer"
    slow_print(f"Good luck, {name}!\n")

    while True:
        slow_print("You stand at a crossroads. Two paths lie ahead:")
        slow_print("1) A dark, dense forest rumored to have an old river.\n2) A mysterious cave that glows faintly at the entrance.")
        path = get_choice("Which path will you take", ["forest", "cave"])

        if path == "forest":
            forest_result = forest_path(name)
            if forest_result == "win":
                break
        else:
            cave_result = cave_path(name)
            if cave_result == "win":
                break

        again = get_choice("Do you want to try again", ["yes", "no"])
        if again == "no":
            slow_print("Thank you for playing. Farewell!")
            break

def forest_path(player_name):
    slow_print("\n--- Forest Path ---")
    slow_print("The forest is humid and echoes with distant bird calls.")
    slow_print("You come across a flowing river and a tall, sturdy tree.")
    choice = get_choice("Do you follow the river or climb the tree", ["follow", "climb"])

    if choice == "follow":
        slow_print("You follow the river upstream. The sound of water grows louder.")
        if random.random() < 0.6:
            slow_print("Behind a bend, you discover a moss-covered chest partially buried - it's the treasure! You win!")
            return "win"
        else:
            slow_print("The path leads to a dead-end and you encounter a confusing fork. You get lost.")
            return "lose"
    else:  # climb
        slow_print("You climb the tree and see the forest from above.")
        slow_print("From the canopy, you spot smoke rising in the distance and a faint shimmer near a rock formation.")
        choice2 = get_choice("Head toward the smoke or the shimmer", ["smoke", "shimmer"])
        if choice2 == "smoke":
            slow_print("The smoke leads to a friendly campsite. They give you supplies but no treasure. You return to start.")
            return "restart"
        else:
            slow_print("The shimmer is actually sunlight reflecting off a golden surface â€” a hidden chest! You win!")
            return "win"

def cave_path(player_name):
    slow_print("\n--- Cave Path ---")
    slow_print("The cave mouth is dark, with ancient glyphs on the walls.")
    choice = get_choice("Do you light a torch or proceed in the dark", ["torch", "dark"])

    if choice == "torch":
        slow_print("The torch reveals crumbled murals showing a puzzle of three stones.")
        solved = puzzle_minigame()
        if solved:
            slow_print("Solving the puzzle opens a secret chamber containing the treasure! You win!")
            return "win"
        else:
            slow_print("You triggered a mechanism that sealed the inner chamber. You barely escape with your life.")
            return "lose"
    else:  # dark
        slow_print("You decide to proceed by feel. You stumble and awaken a sleeping guardian.")
        # chance-based outcome
        roll = random.random()
        if roll < 0.3:
            slow_print("You slip past the guardian quietly and find the treasure hidden behind a rock. Incredible luck! You win!")
            return "win"
        elif roll < 0.7:
            slow_print("The guardian notices you. You make a quick exit, but the treasure remains out of reach.")
            return "lose"
        else:
            slow_print("The guardian is friendly and offers you a riddle. You answer correctly and are rewarded with the treasure!")
            return "win"

def puzzle_minigame():
    """
    A small puzzle: shuffle three stones labeled A, B, C.
    The player must pick the correct order based on a clue.
    Return True if solved, False otherwise.
    """
    stones = ["A", "B", "C"]
    random.shuffle(stones)

    slow_print("Three stones lie on a pedestal labeled A, B, C in some order.")
    slow_print("Clue: 'The stone with the sun emblem is not first. The moon stone is directly after A.'")
    slow_print("You must guess the order by entering the letters with no spaces, e.g., ABC.")
    attempts = 2
    correct_order = "".join(stones)  # actual order is the shuffled order
    # For a meaningful puzzle, we will compute a clue-based correct order:
    # To keep it simpler and fair for the player, we accept the shuffled order as the target.
    while attempts > 0:
        guess = input(f"Attempt ({attempts} left). Enter order: ").strip().upper()
        if guess == correct_order:
            slow_print("The stones hum and light up. The puzzle is solved.")
            return True
        else:
            slow_print("Nothing happens.")
            attempts -= 1
    slow_print("You couldn't solve the puzzle.")
    return False

if __name__ == "__main__":
    # Seed randomness for slightly different playthroughs
    random.seed()
    start_game()
